import { Supplier } from './functional/types';
import { F1 } from './typestub-curry';
export declare function deepGetProp<A>(name: string, o: any): A;
export declare function hasProp<A>(k: ObjKey, o: Obj<A>): boolean;
export declare function checkedGetProp<A>(k: ObjKey, o: Obj<A>): A;
export declare function getPropWithDefault<A>(v: A, k: ObjKey, o: Obj<A>): A;
export declare function first_non_null<A>(...args: A[]): A | null;
export declare function ifNull<A>(a: A, b: A): A;
export declare function ifNullF<A>(a: A, f: Supplier<A>): A;
/**
 * @remark won't flatten a
 * */
export declare function ifNullFAsync<A>(a: A, f: Supplier<Promise<A>>): Promise<A>;
export declare function bindFunction(f: Function): Function;
export declare function caseLookup<A, B>(cases: Array<[A, B]>, target: A): B;
export declare function caseFunctionLookup<A, B>(cases: Array<[A, () => B]>, target: A): B;
export type deepF<A> = (() => A) | (() => deepF<A>);
export declare function deepCall<A>(f: deepF<A> | A): A;
export interface Obj<A> {
    [k: string]: A;
    [k: number]: A;
}
export type ObjKey = string | number;
export declare function objForEach<A>(f: (a?: A, k?: ObjKey, o?: Obj<A>) => void): (o: Obj<A>) => void;
export declare function objMap<A, B>(f: (a?: A, k?: ObjKey, o?: Obj<A>) => B): (o: Obj<A>) => B[];
export declare function objFilter<A>(f: (a?: A, k?: ObjKey, o?: Obj<A>) => boolean): (o: Obj<A>) => A[];
export declare function objToArray<A>(o: Obj<A>): Array<[A, ObjKey]>;
export declare function objValues<A>(o: Obj<A>): A[];
export declare function argsToArray<A>(args: IArguments): A[];
/**
 * take all from as ++ take some from args
 * */
export declare function concatArgs<A>(as: ArrayLike<A>, args: ArrayLike<A>, offsetArgs?: number, nArgs?: number): A[];
export declare function copyArray<A>(xs: ArrayLike<A>, offset?: number, count?: number): A[];
export declare function copyToArray<A>(dest: A[], destOffset: number | undefined, src: ArrayLike<A>, srcOffset?: number, count?: number): A[];
export declare function genFunction(n: number, f: Function): Function;
export declare function isDefined(a: any): boolean;
export declare function notDefined(a: any): boolean;
export declare function isNumber(i: string | number): boolean;
export declare function toNumber(i: string | number): number;
/**
 * @param f: consumer function
 * @param end: ending (exclusive)
 * @param start: offset (inclusive)
 * */
export declare function forI(f: (i: number) => void, end: number, start?: number): void;
export declare function mapI<A>(f: (i: number) => A, size: number): A[];
export declare function repeatI<A>(f: () => A, size: number): A[];
/** apply the function without throwing exception */
export declare function tryApply<A, B>(f: (...args: A[]) => B, args: A[]): B | undefined;
/** call the function without throwing exception */
export declare function tryCall<A, B>(f: (...args: A[]) => B, ...args: A[]): B | undefined;
export declare function tryWithDefault<A, B>(f: (...args: A[]) => B, defaultValue: B, args?: A[]): B;
export type ChainObject<A> = (f: (a: A) => void) => ChainObject<A>;
export declare function chainObject<A>(a: A): ChainObject<A>;
export type Type<A> = new (...args: any[]) => A;
export declare function _if(f: () => any): (b: boolean) => void;
export declare function applyIf<A, B>(a: A | false | 0 | null | void, f: F1<A, B>): B | void;
export declare function cast(o: any): any;
export declare function equals<A>(a: A, b: A): boolean;
export declare function not_equals<A>(a: A, b: A): boolean;
export declare function another<A>(a: A, b: A, compare: A): A;
