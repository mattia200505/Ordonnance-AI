/**
 * Created by beenotung on 12/26/16.
 * the curried functions are deprecated due to type system limit
 */
import { Mapper } from './iterative/map';
import { CurryF2 } from './typestub-curry';
/** take all args (ignore arity)
 * apply :: (..args->a) -> ...args -> a
 * */
export declare const apply: Function;
export declare const prop: Function;
/** cannot represent recursive type, o must eventually contains type A */
export declare const deepProp: Function;
/**
 * @remark side effect
 * @return original object
 *
 * setProp :: a -> k -> {k:a} -> {k:a}
 * */
export declare const setProp: Function;
export declare const length: Function;
export declare const filter: Function;
export declare const compose: Function;
/**
 * flip :: (a->b) -> (b->a)
 * */
export declare const flip: Function;
/**
 * lift :: a -> b -> a
 * */
export declare const lift: Function;
export declare const lift_noarg: Function;
export declare const liftError: Function;
export declare const liftError_noarg: Function;
export declare const compose2: any;
export declare const odd: Function;
export declare const even: Function;
export declare const countWhere: Function;
/**
 * @remark side effect
 * apply2 :: (a->*) -> (a->b) -> a -> b
 * */
export declare const apply2: Function;
/**
 * echoF :: (a->*) -> a -> a
 * @example echoF (console.log) (1) ~> console.log(1) +> return 1
 * */
export declare const echoF: any;
export declare const symbolFs: Map<string, CurryF2<any, any, any>>;
export declare const isFunctionType: (x: any) => boolean;
export declare const isNumberType: (x: any) => x is number;
export declare const isStringType: (x: any) => x is string;
/**
 * @remark side effect
 *
 * forEach :: (a->*) -> [a] -> *
 * */
export declare const forEach: Function;
export type EmptyArray<A> = ArrayLike<A>;
export type MaybeSingleton<A> = [A] | EmptyArray<A>;
/**
 * just :: a -> [a]
 * */
export declare const just: Function;
/**
 * none :: * -> []
 * */
export declare const none: Function;
export declare const eq: Function;
export declare const neq: Function;
export declare const gt: Function;
export declare const lt: Function;
/**
 * first :: (a->Bool) -> [a] -> MaybeSingleton a
 * */
export declare const first: Function;
/**
 * any :: (a->Bool) -> [a] -> Bool
 * */
export declare const any: Function;
/**
 * @remark side effect
 * define infix operator (binary function)
 * */
export declare const defineSymbolF: Function;
export declare const add: any;
export declare const minus: any;
export declare const mult: any;
export declare const rem: any;
export declare const div: Function;
export declare const quot: Function;
/** faster */
export declare const quotMod: Function;
export declare const divMod: Function;
export declare const and: any;
export declare const or: any;
export declare const not: any;
export declare const notnot: any;
export declare const symbolF: Function;
export declare const composeFs: Function;
export declare const chainFs: Function;
/**
 * @remark side effect
 * f :: unary function <A,B>
 * args :: ArrayLike<A>
 * */
export declare const doAll: Function;
/**
 * flatten the iterators as a single array
 * */
export declare function iteratorsToArray<A>(itrs: Array<IterableIterator<A>>): A[];
export declare const concatWithoutDup: Function;
export declare const fmap: Function;
/**
 * groupBy :: (a->k) , [a] -> Map k [a]
 * */
export declare function groupBy<A, K>(f: Mapper<A, K>, xs: A[]): Map<K, A[]>;
/**
 * foldl :: (b->a->b) -> b -> [a] -> b
 * */
export declare const foldl: Function;
export declare const foldl1: Function;
/**
 * concat :: [a] -> [a] -> [a]
 * */
export declare const concat: Function;
/**
 * concatAll :: [[a]] -> [a]
 * */
export declare const concatAll: <A>(ass: A[][]) => A[];
/**
 * @remark side effect to as
 * as -> bs -> __update as__
 * */
export declare const pushAll: Function;
/**
 * merge array of plain objects
 *   do not support merging functions
 *   do not support instant object (e.g. Map instance)
 * merge :: [a|b] -> a & b
 * */
export declare const mergeObjs: Function;
/**
 * mergeAll :: (a=>) -> [a] -> [a] -> [a]
 * */
export declare const mergeAll: Function;
/**
 * groupByAll :: (a->k) -> [[a]] -> Map k [a]
 * */
export declare const groupByAll: Function;
/**
 * @remark side effect
 * update :: (a->__update a__) -> [a] -> [a]
 * @return original array
 *
 * more effective then using map if the original array is going to be discarded anyway
 * */
export declare const update: Function;
export declare const map2: Function;
