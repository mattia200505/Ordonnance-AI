"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.search = void 0;
const type_1 = require("./type");
var search;
(function (search) {
    function str_contains(base, query, caseInsensitive = true) {
        if (caseInsensitive) {
            return base.toLocaleLowerCase().indexOf(query.toLocaleLowerCase()) !== -1;
        }
        else {
            return base.indexOf(query) !== -1;
        }
    }
    search.str_contains = str_contains;
    function object_contains_str(base, query, caseInsensitive = true) {
        if (typeof base === 'string' && typeof query === 'string') {
            return str_contains(base, query, caseInsensitive);
        }
        if (typeof base !== 'object') {
            return base === query;
        }
        for (const k of Object.keys(base)) {
            const v = base[k];
            if (typeof v === 'string' && typeof query === 'string') {
                if (str_contains(v, query, caseInsensitive)) {
                    return true;
                }
            }
            else if (v === query) {
                return true;
            }
            else if (Array.isArray(v)) {
                if (v.some(base => object_contains_str(base, query, caseInsensitive))) {
                    return true;
                }
            }
        }
        return false;
    }
    search.object_contains_str = object_contains_str;
    function partialMatch(query, target) {
        const queryType = (0, type_1.getObjectType)(query);
        const targetType = (0, type_1.getObjectType)(target);
        if (queryType !== targetType) {
            return false;
        }
        switch (queryType) {
            case 'AsyncFunction':
            case 'Function':
                throw new Error('unsupported partial match on type: ' + queryType);
            case 'Number':
            case 'Null':
            case 'Undefined':
            case 'String':
                return query === target;
            case 'Array':
                return target.some(t => query.indexOf(t) !== -1);
            case 'Set':
                return partialMatch(Array.from(query), Array.from(target));
            case 'Map': {
                let matched = false;
                const targetMap = target;
                query.forEach((v, k) => {
                    matched = matched || partialMatch(v, targetMap.get(k));
                });
                return matched;
            }
            case 'Object':
                return Object.keys(query).some(key => partialMatch(query[key], target[key]));
            default:
                return query === target;
        }
    }
    search.partialMatch = partialMatch;
})(search || (exports.search = search = {}));
