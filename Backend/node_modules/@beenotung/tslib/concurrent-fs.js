"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFSPool = createFSPool;
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("./fs"));
const task_pool_1 = require("./task/task-pool");
const promises_1 = require("fs/promises");
function createFSPool(concurrentSize) {
    const pool = new task_pool_1.TaskPool(concurrentSize);
    const res = { ...fs };
    for (const [name, func] of Object.entries(fs)) {
        if (typeof func !== 'function' || name.endsWith('Sync')) {
            continue;
        }
        res[name] = function () {
            const args = arguments;
            return pool.runTask(() => func.apply(fs, args));
        };
    }
    res.scanRecursively = async function scanRecursively(args) {
        const { entryPath, onFile, onDir, onComplete, dereferenceSymbolicLinks, skipDir, } = args;
        const checkStat = dereferenceSymbolicLinks ? promises_1.stat : promises_1.lstat;
        const check = async (pathname, basename) => {
            const stat = await checkStat(pathname);
            if (stat.isDirectory()) {
                if (onDir) {
                    await onDir(pathname, basename);
                }
                if (skipDir && skipDir(pathname, basename)) {
                    return;
                }
                const names = await (0, promises_1.readdir)(pathname);
                await Promise.all(names.map(basename => {
                    const childPathname = path.join(pathname, basename);
                    return check(childPathname, basename);
                }));
                return;
            }
            if (onFile && stat.isFile()) {
                await onFile(pathname, basename);
                return;
            }
        };
        await check(entryPath, path.basename(entryPath));
        if (onComplete) {
            await onComplete();
        }
    };
    return res;
}
