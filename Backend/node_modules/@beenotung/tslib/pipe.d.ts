export type PipeArg<A, B> = [(a: A) => B, A[]] | [(a: A) => B];
/**
 * the function<A,B> :: A,...* -> B
 *   - first argument must be type A
 *   - other arguments can be any type
 *   - must return type B
 *
 * @example
 *   pipe([
 *     [ x=>x+2 ]
 *   , [ (x,y)=>x*2+y, [5] ]
 *   ]) (2) ~> 13
 * */
/**
 * auto curried Elixir style pipe
 *
 * pipe :: PipeArg p => [p] -> a -> *
 *   - don't have to be of same type (like chain)
 * */
export declare const pipe: Function;
/**
 * non-curried version of echoF in functional.ts
 *
 * echo :: (a->*) -> a -> a
 * */
export declare function peek<A>(f: (a: A) => any): (a: A) => A;
export interface Chain<A> {
    /**
     * a.k.a. peek
     * will not affect the value, can perform side effect
     * */
    use(f: (a: A) => any): Chain<A>;
    map<B>(f: (a: A) => B): Chain<B>;
    unwrap(): A;
}
export declare class Chain<A> {
    private value;
    constructor(value: A);
}
export declare function createChain<A>(a: A): Chain<A>;
