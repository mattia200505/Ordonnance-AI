"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enum_i2s = enum_i2s;
exports.enum_s2i = enum_s2i;
exports.enum_next_i = enum_next_i;
exports.enum_next_s = enum_next_s;
exports.enum_keys = enum_keys;
exports.enum_indices = enum_indices;
exports.enum_values = enum_values;
exports.enum_last_i = enum_last_i;
exports.enum_last_s = enum_last_s;
exports.enum_is_last_i = enum_is_last_i;
exports.enum_is_last_s = enum_is_last_s;
exports.enum_is_last = enum_is_last;
exports.enum_is_in_range = enum_is_in_range;
exports.enum_not_equals = enum_not_equals;
exports.enum_set_string = enum_set_string;
exports.enum_only_string = enum_only_string;
const strict_type_1 = require("./strict-type");
function is_enum_key(x) {
    return x != +x;
}
/**
 * for the sake of implicit any in object index
 * */
function enum_i2s(e, i) {
    const res = e[i];
    if (res === void 0) {
        throw new TypeError(`Invalid index '${String(i)}' in enum`);
    }
    return (0, strict_type_1.ensureString)(res);
}
function enum_s2i(e, s) {
    const res = e[s];
    if (res === void 0) {
        throw new TypeError(`Invalid key '${s}' in enum`);
    }
    return (0, strict_type_1.ensureNumber)(res);
}
function enum_next_i(e, i) {
    const res = e[e[i + 1]];
    if (res === void 0) {
        throw new TypeError(`Enum of index '${i}' don't have next value`);
    }
    return res;
}
function enum_next_s(e, s) {
    const res = e[e[s] + 1];
    if (res === void 0) {
        throw new TypeError(`Enum of key '${s}' don't have next value`);
    }
    return res;
}
function enum_keys(e) {
    return Object.keys(e).filter(is_enum_key);
}
/**
 * numeric values
 * */
function enum_indices(e) {
    const n = enum_last_i(e) + 1;
    const res = new Array(n);
    for (let i = 0; i < n; i++) {
        res[i] = i;
    }
    return res;
}
/**
 * numeric or string values
 * if    original enum -> numeric values;
 *    stringified enum -> string values
 * */
function enum_values(e) {
    return enum_keys(e).map(s => e[s]);
}
function enum_last_i(e) {
    return e[enum_last_s(e)];
}
function enum_last_s(e) {
    const ks = Object.keys(e);
    return ks[ks.length - 1];
}
function enum_is_last_i(e, i) {
    return i === enum_last_i(e);
}
function enum_is_last_s(e, s) {
    return s === enum_last_s(e);
}
function enum_is_last(e, v) {
    if (typeof v === 'number') {
        return enum_is_last_i(e, v);
    }
    else {
        return enum_is_last_s(e, v);
    }
}
function enum_is_in_range(e, v) {
    return v in e;
}
function enum_not_equals(e1, e2) {
    return e1 !== e2;
}
/**
 * inplace update
 *
 * @return original (modified) enum
 * */
function enum_set_string(e) {
    Object.keys(e)
        .filter(is_enum_key)
        .forEach(s => (e[s] = e[e[s]]));
    return e;
}
/**
 * inplace update
 * */
function enum_only_string(e) {
    Object.keys(e).forEach(i => {
        if (i == +i) {
            const s = e[i];
            e[s] = s;
            delete e[i];
        }
    });
    return e;
}
