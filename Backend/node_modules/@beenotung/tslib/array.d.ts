import { CompareResult } from './compare';
import { Maybe } from './maybe';
/**
 * inplace delete all element from the array
 * @return old elements
 * */
export declare function clearArray<A>(xs: A[]): A[];
/**
 * inplace replace all element in the array
 * @return the old elements
 * */
export declare function replaceArray<A>(dest: A[], src: A[]): A[];
/**
 * only use `===` to compare
 * @warning slow
 * @return new array
 * */
export declare function unique<A>(xs: A[]): A[];
export declare function rightMost<A>(n: number, xs: A[]): A[];
export declare function leftMost<A>(n: number, xs: A[]): A[];
/** inplace update */
export declare function popN(n: number, xs: any[]): void;
/** inplace update */
export declare function popUntilN(n: number, xs: any[]): void;
/** inplace update */
export declare function shiftN(n: number, xs: any[]): void;
/** inplace update */
export declare function shiftUntilN(n: number, xs: any[]): void;
export declare function last<A>(xs: ArrayLike<A>, skipCheck?: boolean): A;
export declare function maybeLast<A>(xs: A[]): Maybe<A>;
export declare function fromFileList(files: FileList): File[];
export declare function array_contains<A>(xs: A[], x: A): boolean;
export declare function insert<A>(xs: A[], index: number, x: A): void;
export type OrderType = 'ascending' | 'descending';
export type Comparator<A> = (a: A, b: A) => CompareResult;
/**
 * insert into Ascending sorted array
 * */
export declare function insert_sorted<A>(xs: A[], comparator: (a: A, b: A) => CompareResult, x: A, order?: OrderType): void;
export declare const defaultComparator: Comparator<any>;
/**
 *
 * wrapper of slice, because it's confusing between slice and splice
 *
 * performance reference: https://jsperf.com/array-clone
 * */
export declare function cloneArray<T>(xs: T[]): T[];
/**
 * @return in-place sorted, original array
 * */
export declare function sort<T>(xs: T[], comparator?: Comparator<T>): T[];
/**
 * @remark inplace update
 * @return original array
 * */
export declare function removeByIdx<A>(xs: A[], i: number): A[];
/**
 * @remark inplace update
 * @return original array
 * */
export declare function remove<A>(xs: A[], x: A): void;
/**
 * @remark inplace update
 * @return original array
 * */
export declare function removeBy<A>(xs: A[], f: (a: A) => boolean): A[];
export declare function nodup<A>(xs: A[]): A[];
/**
 * inplace delete all duplicated element from the array (only one copy is kept)
 * @return old array
 * */
export declare function removeDup<A>(xs: A[]): A[];
/**
 * inplace insert elements into the array
 * @return old array
 * */
export declare function insertNoDup<A>(acc: A[], newXs: A[]): A[];
/**
 * inplace insert elements into the array
 * @return old array
 * */
export declare function insertNoDupWithKey<A>(acc: A[], newXs: A[], key: string): A[];
/**
 * inplace operation
 * @return old array
 * */
export declare function removeDupByKey<A>(xs: A[], key: string | number): A[];
/**
 * inplace update
 * @return old array
 * */
export declare function removeByKey<A>(xs: A[], key: string | number, keys: Array<string | number>): A[];
/**
 * including end
 * */
export declare function arrayFromRange(start: number, end: number, step?: number): number[];
/** @deprecated renamed to arrayFromRange */
export declare const range: typeof arrayFromRange;
export declare function repeat<T>(x: T, n: number): T[];
export declare function filterByKey<A>(src: A[], key: string, keys: string[]): A[];
/** @deprecated use Array.from(xs) instead */
export declare function toArray<A>(xs: ArrayLike<A>): A[];
export declare function flatten<A>(xss: A[][]): A[];
/**
 * array.push is not monadic, this is a wrapper to make it monadic
 * */
export declare function push<A>(res: A[], ...xs: A[]): A[];
export declare function binArray<A>(xs: A[], binSize: number): A[][];
/**
 * non-curry version of `groupBy` in functional.ts
 * */
export declare function binArrayBy<A, K>(xs: A[], mapper: (a: A) => K): Map<K, A[]>;
export declare function partitionArrayBy<A>(xs: A[], f: (a: A) => boolean): [A[], A[]];
export declare function zipArray<A, B>(a: A[], b: B[]): Array<[A, B]>;
export declare function countArray<A>(xs: A[], f: (a: A, i: number, xs: A[]) => boolean): number;
export declare function asyncCountArray<A>(xs: A[], f: (x: A, i: number, xs: A[]) => Promise<boolean>): Promise<number>;
export declare function max<T>(xs: T[]): T | undefined;
export declare function min<T>(xs: T[]): T | undefined;
export declare function sum(xs: number[]): number;
export declare function average(xs: number[]): number;
export declare const mean: typeof average;
export declare function standard_deviation(xs: number[], mode?: 'sample' | 'population', mean?: number): number;
export declare function standard_score(xs: number[], mode?: 'sample' | 'population'): number[];
export declare const z_score: typeof standard_score;
export declare function sumByFunc<T>(xs: T[], mapper: (x: T) => number): number;
export declare function maxByFunc<T>(xs: T[], comparator: (a: T, b: T) => CompareResult): T | undefined;
export declare function minByFunc<T>(xs: T[], comparator: (a: T, b: T) => CompareResult): T | undefined;
export declare function maxByField<T, K extends keyof T>(xs: T[], key: K): T | undefined;
export declare function minByField<T, K extends keyof T>(xs: T[], key: K): T | undefined;
export declare function sumByField<T extends Record<K, number>, K extends keyof T>(xs: T[], key: K): number;
/**
 * side-effect: the array will be sorted in-place if instructed
 *
 * default will sort the array
 * */
export declare function median<T>(xs: T[], options?: {
    sort?: boolean | typeof defaultComparator;
    merger?: (a: T, b: T) => T;
}): T | undefined;
export declare function countElement<T>(xs: T[], x: T): number;
export declare function countAll<T>(xs: T[]): Map<T, number>;
export declare function mode<T>(xs: T[]): T | undefined;
export declare function shuffle<T>(xs: T[], n?: number): T[];
export declare function shuffledBinArray<T>(xs: T[], binSize: number, nSwap?: number): T[][];
export declare function shuffledIndices(n: number): number[];
/**
 * TODO assign a better name
 * e.g. f [a,b,c] 1 ~~> [[a],[b],[c]]
 * e.g. f [a,b,c] 2 ~~> [ [a,a],[a,b],[a,c],
 *                        [b,a],[b,b],[b,c],
 *                        [c,a],[c,b],[c,c] ]
 * */
export declare function genCombination<T>(cs: T[], size: number): T[][];
export type IoList<T> = T[] | T[][] | T[][][] | T[][][][] | T[][][][][] | T[][][][][][] | T[][][][][][][] | any[];
export declare function flattenAll<T>(xs: IoList<T>): T[];
export declare function getMaxArraySize(): number;
export declare function pushForward<T>(xs: T[], x: T): void;
export declare function pushBackward<T>(xs: T[], x: T): void;
export declare function makeArray<T>(n: number, f: (i: number) => T): T[];
export declare function arrayToObject<T>(xs: T[], keyFn: (x: T, i: number, xs: T[]) => string): Record<string, T>;
