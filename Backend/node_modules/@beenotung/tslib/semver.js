"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemverDiffType = void 0;
exports.to_semver = to_semver;
exports.is_semver = is_semver;
exports.is_newer = is_newer;
exports.is_compatible = is_compatible;
exports.getSemverDiffType = getSemverDiffType;
const enum_1 = require("./enum");
const lang_1 = require("./lang");
function to_semver(s) {
    const res = s.split('.').map(x => +x);
    if (res.length !== 3 || res.find(x => !(0, lang_1.isNumber)(x))) {
        throw new TypeError('input is not a valid semver string');
    }
    return res;
}
function is_semver(s) {
    try {
        return to_semver(s).length === 3;
    }
    catch (e) {
        return false;
    }
}
function is_newer(base, compare) {
    return (compare[0] > base[0] ||
        (compare[0] === base[0] &&
            (compare[1] > base[1] ||
                (compare[1] === base[1] && compare[2] > base[2]))));
}
function is_compatible(base, compare) {
    return (compare[0] === base[0] &&
        ((compare[1] === base[1] && compare[2] <= base[2]) || compare[1] <= base[1]));
}
var SemverDiffType;
(function (SemverDiffType) {
    SemverDiffType[SemverDiffType["breaking"] = 0] = "breaking";
    SemverDiffType[SemverDiffType["compatible"] = 1] = "compatible";
    SemverDiffType[SemverDiffType["same"] = 2] = "same";
    SemverDiffType[SemverDiffType["newer"] = 3] = "newer";
})(SemverDiffType || (exports.SemverDiffType = SemverDiffType = {}));
(0, enum_1.enum_only_string)(SemverDiffType);
function getSemverDiffType(base, compare) {
    return base.join('.') === compare.join('.')
        ? SemverDiffType.same
        : is_newer(base, compare)
            ? SemverDiffType.newer
            : is_compatible(base, compare)
                ? SemverDiffType.compatible
                : SemverDiffType.breaking;
}
