"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheDir = void 0;
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const ignore_1 = require("./ignore");
const path_1 = require("path");
/**
 * @description Cache and re-use computation result with custom filename and directory.
 * */
class CacheDir {
    dir;
    expireInterval;
    constructor(options) {
        this.dir = options?.dir || '.cache';
        this.expireInterval = options?.expireInterval || 15 * 60 * 1000;
        (0, fs_1.mkdirSync)(this.dir, { recursive: true });
        if (options?.gitignore !== false) {
            (0, ignore_1.appendIgnoreLine)(options?.gitignore || '.gitignore', this.dir);
        }
    }
    runSync(args) {
        const file = (0, path_1.join)(this.dir, args.filename);
        if (args.filename.includes('/') || args.filename.includes('\\')) {
            const dir = (0, path_1.dirname)(file);
            (0, fs_1.mkdirSync)(dir, { recursive: true });
        }
        try {
            const stats = (0, fs_1.statSync)(file);
            const passedTime = Date.now() - stats.mtimeMs;
            if (passedTime < this.expireInterval) {
                const buffer = (0, fs_1.readFileSync)(file);
                if (args.as === 'string')
                    return buffer.toString();
                return buffer;
            }
        }
        catch (error) {
            // file not exists or name clash with directory
        }
        const result = args.fn();
        (0, fs_1.writeFileSync)(file, result);
        return result;
    }
    async runAsync(args) {
        const file = (0, path_1.join)(this.dir, args.filename);
        if (args.filename.includes('/') || args.filename.includes('\\')) {
            const dir = (0, path_1.dirname)(file);
            await (0, promises_1.mkdir)(dir, { recursive: true });
        }
        try {
            const stats = await (0, promises_1.stat)(file);
            const passedTime = Date.now() - stats.mtimeMs;
            if (passedTime < this.expireInterval) {
                const buffer = await (0, promises_1.readFile)(file);
                if (args.as === 'string')
                    return buffer.toString();
                return buffer;
            }
        }
        catch (error) {
            // file not exists or name clash with directory
        }
        const result = await args.fn();
        (0, promises_1.writeFile)(file, result);
        return result;
    }
}
exports.CacheDir = CacheDir;
